<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Explanation / demonstration of CSS selectors, and some pseudo-elements</title>
    <meta name="description" content="Markup supporting selectors.css">
    <link rel="stylesheet" href="meta.css">
    <link rel="stylesheet" href="selectors.css">
</head>
<body>
    <header role="banner">
        <h1>Explanation / demonstration of CSS selectors, and some pseudo-elements</h1>
    </header>
<!--TODO: mention types of selectors, see level 4 spec-->
    <section>
        <h2>Basic</h2>
        <article>
            <h3>Universal selector</h3>
            <p>Match all non-pseudo-elements with <code>*</code>. So, to set all non-pseudo-elements in sans serif, use <code>* { font-family: sans-serif; }</code></p>
        </article>

        <article>
            <h3>Element selector</h3>
            <p>Match the <code>&lt;dt&gt;</code> element with the <code>dt</code> selector, so you can say this: <code>dt {  text-transform: uppercase; }</code>, and get this:</p>
            <dl>
                <dt>Some term</dt>
                <dd>An amazingly spot on definition of "some term".</dd>
            </dl>
        </article>

        <article>
            <h3>class selector</h3>
            <p>Match <span class="cls-bigger">elements with the class name <code>.cls-bigger</code></span></p>
        </article>

        <article>
            <h3>multiple class selector</h3>
            <p>Match <span class="cls-bigger cls-blue">an element</span> that is both
                <code>.cls-bigger</code> and <code>.cls-blue</code> with the multiple class selector <code>.cls-bigger.cls-blue</code>. In this case let's italicise it with <code>.cls-bigger.cls-blue {font-style: italic; }</code></p>
        </article>

        <article>
            <h3>id selector</h3>
            <p>Use the selector <code>#me</code> to match <span id="me">an element with an id of <code>me</code></span>.</p>
        </article>
    </section>

    <section>
        <h2>Attributes</h2>
        <article>
            <h3>attribute selector: simple presence</h3>
            <p>Match an element assigned the attribute <code>data-hello-world</code> with the selector <code>[data-hello-world]</code>. This will match no matter what the value of the attribute, or even if the attribute doesn't have a value.</p>
            <ul class="attribute-simple-presence-search">
                <li><code>data-hello-world="true"</code> <span data-hello-world="true">matches</span>;</li>
                <li><code>data-hello-world="false"</code> <span data-hello-world="true">matches</span>;</li>
                <li><code>data-hello-world="unicorns"</code> <span data-hello-world="unicorns">matches</span>, and</li>
                <li>the minimal <code>data-hello-world</code> also <span data-hello-world> matches</span>.</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: exact value match, case insensitive</h3>
            <p>Match those elements with the attribute <code>data-highlight-color</code> set to the value "blue" <strong>or</strong> e.g. "BLUE" (or any other case variation of the same string) using the selector <code>[data-highlight-color="blue" i]</code></p>
            <ul class="attribute-exact-match-case-insensitive-search">
                <li><code data-highlight-color="blue">data-highlight-color="blue"</code></li>
                <li><code data-highlight-color="BLUE">data-highlight-color="BLUE"</code></li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: exact value match, implicitly case sensitive</h3>
            <p>Only match those elements with the attribute <code>data-highlight-color</code> set to the value "RED" <strong>but not</strong>, e.g. "red" (nor any other case variation of the same string), using the selector <code>[data-highlight-color="RED"]</code>:</p>
            <ul class="attribute-exact-match-case-sensitive-search">
                <li><code data-highlight-color="red">data-highlight-color="red"</code></li>
                <li><code data-highlight-color="RED">data-highlight-color="RED"</code></li>
            </ul>
            <p>Note that case sensitivity can be explicitly specified with the selector <code>[data-highlight-color="RED" s]</code> under level 4, but not sure why you'd want to.</p>
        </article>

        <article>
            <h3>attribute selector: word match</h3>
            <p>Make the text green if "grass" is a word (a whitespace-separated string) in the value of the <code>data-ground-type</code> attribute, by matching <code>[data-ground-type~="grass"]</code> </p>
            <ul class="attribute-word-match-search">
                <li><span data-ground-type="grass outside">this field</span> has the attribute <code>data-ground-type="grass outside"</code> and matches</li>
                <li><span data-ground-type="outside grass">this meadow</span> has the attribute <code>data-ground-type="outside grass"</code> and matches</li>
                <li><span data-ground-type="outside grass garden">this lawn</span> has the attribute <code>data-ground-type="outside grass garden"</code> and matches</li>
                <li><span data-ground-type="outside patio">this patio</span> has the attribute <code>data-ground-type="outside patio"</code> and doesn't match</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: starts with string</h3>
            <p>Match fully qualified links with <code>[href^="http"]</code></p>
            <ul class="attribute-starts-with-search">
                <li>An <a href="http://external-link">external link</a> has an indicator</li>
                <li>A <a href="#">page fragment link to the current page</a> doesn't</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: ends with string</h3>
            <p>Match links ending in ".pdf" with <code>[href$=".pdf"]</code></p>
            <ul class="attribute-ends-with-match-search">
                <li>A <a href="made-up-path.pdf">link to a PDF</a> has an indicator</li>
                <li>A <a href="#">link to not-a-pdf</a> doesn't</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: substring match</h3>
            <p>Match links containing the string "untrusted" in their path with <code>[href*="untrusted"]</code>.</p>

            <p class="attribute-substring-match">Browse the <a href="./safe/">safe</a> content with confidence, but be careful of the
                <a href="./untrusted">untrusted</a> content.
        </article>

        <article>
            <h3>attribute selector: beginning of a hyphen-separated value list</h3>
            <p>Used mainly for the use case: matching of elements with any <code>en</code> value of <code>hreflang</code>.</p>
            <ul class="attribute-hyphen-separated-list-start-search">
                <li><a href="#" hreflang="en-UK">Good morning from the UK!</a></li>
                <li><a href="#" hreflang="en-AU">G'day from Oz!</a></li>
                <li><a href="#" hreflang="en-US">Howdy from the States!</a></li>
                <li><a href="#" hreflang="en">Hello from an unspecified English region</a></li>
                <li><a href="#" hreflang="fr">Bonjour de France!</a></li>
            </ul>

        </article>
    </section>

    <section>
        <h2>Structural complex selectors</h2>
        <article>
            <h3>Descendant selector</h3>
            <p>Match any <code>&lt;span&gt;</code> living anywhere inside a <code>&lt;ul&gt;</code>, with <code>ul span</code>.</p>
            <div class="descendant-selector-search">
                <ul>
                    <li>I am not a span and so am not italic</li>
                    <li><span>I am an italic span as I'm inside a <code>ul</code>.</span></li>
                </ul>
                <span>I'm a span outside any <code>ul</code>, so am not italic.</span>
            </div>
        </article>

        <article>
            <h3>Child selector</h3>
            <p>Match any child <code>&lt;p&gt;</code> of <code>.parent</code>, but none nested more deeply, by using <code>.parent > p</code>, in this case turning it steel blue.</p>
            <div class="child-selector-search">
                <p>The <code>&lt;p&gt;</code> in <code>&lt;div class="parent"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;</code> is a child of <code>.parent</code>, so this matches.</p>
                <div>
                    <p>The <code>&lt;p&gt;</code> in <code>&lt;div class="parent"&gt;&lt;div&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</code> is not a child of <code>.parent</code>, so this doesn't match.</p>
                </div>
            </div>
        </article>

        <article>
            <h3>Adjacent sibling selector</h3>
            <p>Match a target element that immediately follows a specified sibling with <code>immediately-preceding-sibling-selector + target-selector</code></p>
            <ul class="adjacent-sibling-search">
                <li>earlier sibling</li>
                <li class="specified-immediately-preceding-sibling">specified immediately preceding sibling</li>
                <li>the target</li>
                <li>later sibling</li>
            </ul>
        </article>

        <article>
            <h3>Following siblings selector</h3>
            <p>Match one or more targets that follow a specified sibling with <code>preceding-sibling-selector ~ target</code>.</p>
            <ul class="following-sibling-search">
                <li>earlier sibling</li>
                <li class="specified-preceding-sibling">specified preceding sibling</li>
                <li>a target</li>
                <li>another target</li>
            </ul>
        </article>

        <article>
            <h3>Table / grid column selector</h3>
            <p>Match a target within the specified column of a table or grid. No implementations yet in 2020, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Column_combinator">more details on MDN</a>.</p>
        </article>

    </section>

    <section>
        <h2>Logical pseudo-classes</h2>
        <article>
            <h3>:is</h3>
            <p><code>:is</code> (used to be called <code>:matches</code>), takes a list of elements, any one of which will cause a match. Here, elements selected with <code>:is(span, q)</code> are coloured blue:</p>
            <div class="root-of-is-search">
                <span>I'm a <code>matching span</code></span> and <q>I'm a <code>matching q</code></q>, but <i>I'm a non-matching <code>i</code></i>.
            </div>
            <p>Note that unlike the usual parsing rules of CSS, the selector list within <code>is</code> is forgiving: if a selector within <code>is</code> is not recognised by the browser, rather than invalidating the entire selector containing <code>is</code>, only the individual invalid selector within <code>is</code> is ignored.</p>
            <p><code>is</code> takes the specificity of the most specific selector in its arguments.</p>
            <p><a href="https://caniuse.com/css-matches-pseudo">Check browser support</a>.</p>
        </article>

        <article>
            <h3>:where</h3>
            <p><code>:where</code> always has a specificity of 0, but otherwise is identical to <code>:is</code>.
        </article>

        <article>
            <h3>:has</h3>
            <p><code>:has</code> takes a selector list as an argument and matches the selector it's bound to when any selector in the list matches. This could easily be used to match an element based on its descendants. Before level 4 this was not possible in CSS. Unfortunately as of Jan 2021 there is no browser support yet, but you can
                <a href="https://caniuse.com/?search=%3Ahas">keep an eye on it</a>.</p>
        </article>

        <article>
            <h3>:not</h3>
            <p>
                <code>:not</code> matches elements that do not match the supplied selector or selector list. Note that you can't pass pseudo-elements, they won't work with <code>:not</code>. Browser support is good for passing a single selector; if you want to pass a selector list (this is the level 4 addition),
                <a href="https://caniuse.com/css-not-sel-list">check browser support</a>.
            </p>

            <h4>Passing a single selector</h4>
            <p>To match all but the third child in the list, use <code>li:not( :nth-child(3) )</code></p>
            <ul class="not-single-selector-search">
                <li>I am child number 1</li>
                <li>I am child number 2</li>
                <li>I am child number 3</li>
                <li>I am child number 4</li>
            </ul>
            <p>You can chain individual single selector <code>:not</code>s together to get some of the effect of a selector list, for example to match all but the first and last list items, you can use <code>li:not(:first-child):not(:last-child)</code></p>
            <ul class="not-multiple-single-selectors-search">
                <li>I am child number 1</li>
                <li>I am child number 2</li>
                <li>I am child number 3</li>
                <li>I am child number 4</li>
            </ul>


            <h4>Passing a selector list</h4>
            <p>To match all but the first and last list items, as above but using a selector list instead of multiple <code>:not</code> clauses, use <code>li:not( :first-child, :last-child)</code></p>
            <ul class="not-selector-list-search">
                <li>I am child number 1</li>
                <li>I am child number 2</li>
                <li>I am child number 3</li>
                <li>I am child number 4</li>
            </ul>
        </article>
    </section>

    <section>
        <h2>Structural pseudo-classes</h2>
        <article>
            <h3>:root</h3>
            <p><code>:root</code> matches the root element. Can also use <code>&lt;html&gt;</code> in html docs, but <code>:root</code> is necessary for other doc types e.g. XML, SVG etc.</p>
        </article>

        <article>
            <h3>:empty</h3>
            <p><code>:empty</code> matches empty elements. N.B. element nodes and text nodes (including whitespace) prevent a containing element from being empty. Comment nodes do not prevent their parent element from being empty.</p>
            <p>Here, empty list items have a background pattern applied.</p>
            <ul class="root-of-empty-search">
                <li>First element</li>
                <li></li>
                <li>Third element</li>
            </ul>
        </article>

        <h3>Child-indexed pseudo-classes</h3>
        <p>Selectors level 3 describes this type of matching as being based on the index of the target  element relative to its parent, as encapsulated in the inclusion of "child" in some of the pseudo-class names. Selectors level 4 allows for a non-element parent, or no parent at all, by describing an element's relative index with respect to its siblings. Language in this section refers to "child" to match the pseudo class names, but if you're in a level 4 implementation, the implied parent is not a requirement.</p>

        <p>Note that <em>indices are always 1-indexed</em>.</p>

        <article>
            <h3>:only-child</h3>
            <p><code>:only-child</code> matches if an element is the only child element of its parent.</p>
            <p class="only-child-search">In this paragraph, <span>I am the only child element, so I match, (it doesn't matter what type of element I am).</span></p>
            <p class="only-child-search">In this paragraph, there is more than one child, both <i>here</i> and <i>here</i>, so the <code>:only-child</code> selector doesn't find a match.</p>
        </article>

        <article>
            <h3>:only-of-type</h3>
            <p><code>:only-of-type</code> matches an element of specified type that is the only child element of that type of its parent. Here we're using <code>span:only-of-type</code> to target <code>&lt;span&gt;</code> elements that are the only span element of their parents:</p>
            <p class="only-of-type-search">In this paragraph, <span>this <code>&lt;span&gt;</code></span>, and <label>this <code>&lt;label&gt;</code>element</label>, are the only child elements of their respective types, so the <code>span:only-child-of-type</code> selector matches the span but not the label.</p>
            <p class="only-of-type-search">In this paragraph, both <span>this <code>&lt;span&gt;</code></span>, and <span>this <code>&lt;span&gt;</code></span>, are child elements of the same parent, so the selector doesn't match.</p>
        </article>

        <article>
            <h3>:first-child</h3>
            <p><code>:first-child</code> matches an element that is the first child of its parent.</p>
            <ul class="first-child-search">
                <li>first child</li>
                <li>second child</li>
                <li>third child</li>
            </ul>
        </article>

        <article>
            <h3>:first-of-type</h3>
            <p><code>:first-of-type</code> matches an element that is the first child element of its type, (it needn't be the first overall element child). Here we're using <code>span:first-of-type</code> to select the first <code>&lt;span&gt;</code> element.</p>
            <p class="root-of-first-of-type-search">This paragraph contains a <label><code>&lt;label&gt;</code></label>, this first <span><code>&lt;span&gt;</code> which matches</span>, and this second <span><code>&lt;span&gt;</code></span>, which doesn't.</p>
        </article>

        <article>
            <h3>:last-child</h3>
            <p><code>:last-child</code> is the converse of <code>:first-child</code>.</p>
            <ul class="root-of-last-child-search">
                <li>first child</li>
                <li>second child</li>
                <li>last child</li>
            </ul>
        </article>

        <article>
            <h3>:last-of-type</h3>
            <p><code>:last-of-type</code> is the converse of <code>:first-of-type</code>.</p>
            <p class="root-of-last-of-type-search">This paragraph contains a <label><code>&lt;label&gt;</code></label>, this first <span><code>&lt;span&gt;</code> which doesn't match</span>, and this second <span><code>&lt;span&gt;</code>, which does</span>.</p>
        </article>

        <article>
            <h4>The An+B microsyntax</h4>
            <p>Some of these function-like pseudo-elements are invoked with <code>(An+B)</code>, which can be useful to match a specific child, or all child elements at regularly spaced intervals. Child-indexed pseudo-class selectors using this microsyntax match a child element when its index is the result of the evaluation of terms inside the parentheses. You can think of the child list as being is divided into <code>A</code> groups (the last group also containing any remainder), and it's the <code>B</code>th element of each group that is matched.</p>
            <p>For <code>An+B</code>, <code>n</code> is a literal representing consecutive integers between 0 and the number of child elements, <code>A</code>represents a multiple of <code>n</code>, and <code>B</code> is an integer offset which may be positive, negative, or 0.</p>
            <ul>
                <li>If <code>A</code> is 0 it may be omitted, so the expression becomes <code>(B)</code>, which will match exactly one element with that index (if a child element of the specified index exists).</li>
                <li>If <code>A</code> is 1 or -1, it may be omitted, as long as the correct sign is applied to <code>n</code>, so that <code>1n</code> becomes <code>n</code> and <code>-1n</code> becomes <code>-n</code>.</li>
                <li>If B is 0 it may be omitted, so the expression becomes <code>(An)</code>, which will match every Ath child element.</li>
                <li>If B is negative, the expression becomes <code>(An-B)</code></li>
            </ul>
            <p>Just a few of the things you can do with this are shown as examples below:</p>


            <h4>:nth-child(An+B of S)</h4>
            <p>Counts from the beginning of the list of child elements.</p>
            <p><code>S</code> represents a user-supplied selector list used to scope the child list, think of it as a more flexible version of <code>:nth-of-type</code> where you're not restricted to scoping by the type of the child element. [Note that as at December 2020, only Safari supports <code>of S</code>, so the scoping isn't ready for prime time yet, but keep an eye on the
                <a href="https://caniuse.com/css-nth-child-of">browser support</a>.</p>
            <h5>exactly this one, specific child</h5>
            <p><code>:nth-child(2)</code> will match exactly the second child.</p>
            <ul class="root-of-nth-child-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h5>the first 4 children</h5>
            <p><code>:nth-child(-n+4)</code> will match the first four children.</p>
            <ul class="root-of-nth-child-first-four-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h5>every second child</h5>
            <p><code>:nth-child(2n)</code> will match every other child, starting with the second. (Note that <code>2n</code> is aliased to <code>even</code>, so the more readable <code>:nth-child(even)</code> may be preferred.)</p>
            <ul class="root-of-nth-child-xn-even-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <p><code>:nth-child(2n+1)</code> will match every other child, starting with the first. (Note that <code>2n+1</code> is aliased to <code>odd</code>, so the more readable <code>:nth-child(odd)</code> may be preferred.)</p>
            <ul class="root-of-nth-child-xn-odd-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h5>every third child, starting counting from the second</h5>
            <p><code>:nth-child(3n+2)</code> will match the second child, then every third one after that.</p>
            <ul class="root-of-nth-child-xn-offset-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
                <li>Eighth child</li>
                <li>Ninth child</li>
                <li>Tenth child</li>
                <li>Eleventh child</li>
                <li>Twelfth child</li>
                <li>Thirteenth child</li>
                <li>Fourteenth child</li>
            </ul>
        </article>

        <article>
            <h4>:nth-last-child(An+B)</h4>
            <p>The same as <code>:nth-child</code>, but counting from the end rather than the beginning of the list of child elements.</p>
        </article>

        <article>
            <h4>:nth-of-type(An+B)</h4>
            <p>As <code>:nth-child</code>, but only elements of the element type to match are included in the evaluation of the child count. It is more specific than <code>:nth-child</code>.</p>
        </article>

        <article>
            <h4>:nth-last-of-type(An+B)</h4>
            <p>As <code>:nth-last-child</code>, but only elements of the element type to match are included in the evaluation of the child count. It is more specific than <code>:nth-last-child</code>.</p>
        </article>

        <article>

            <h3>Shadow DOM</h3>

            <h4>:host, :host(selector) and :host-context(selector)</h4>
            <p>These are used to target the Shadow host <b>from within the Shadow DOM CSS</b>. Shouldn't really be possible as the Shadow host is outside of the Shadow root, but there are
                <a href="https://drafts.csswg.org/css-scoping/#host-element-in-tree">good reasons for it</a>. Basically, Shadow hosts are weird.</p>
            <p><code>:host</code> matches the Shadow tree's Shadow host.</p>
            <p><code>::host(selector)</code> matches the Shadow tree's Shadow host if it also matches the selector.</p>
            <p><code>:host-context(selector)</code> matches a Shadow host if it, or one of its Shadow-including ancestors matches the selector (meaning that this selector pierces Shadow boundaries in its upward search). Browser support patchy (Jan 2021), so
                <a href="https://caniuse.com/mdn-css_selectors_host-context">check before you use.</a>
            </p>
        </article>
    </section>

    <section>
        <h2>Dynamic pseudo-classes</h2>
        <article>
            <h3>Location pseudo-classes</h3>
            <ul>
                <li><code>:link</code> matches any unvisited <code>&lt;a&gt;</code>.</li>
                <li><code>:visited</code> matches any visited <code>&lt;a&gt;</code>.</li>
                <li><code>:local-link</code> matches any reflexive link within the current document. If the <code>href</code> includes a fragment identifier, this must be matched in the document's URL for the selector to match. No browser support data available as of 2020.</li>
                <li><code>:any-link</code> matches any <code>&lt;a&gt;</code>, <code>&lt;area&gt;</code> or <code>&lt;link&gt;</code> with an <code>href</code> attribute.</li>
                <li><code>:target</code> matches the element referenced by the document URL's fragment identifier, if any.</li>
                <li><code>:target-within</code> matches when an element, or a descendant element, is referenced by the document URL's fragment identifier, if any. (This is a rare example in CSS of being able to style an ancestor based on a descendant. <a href="https://caniuse.com/mdn-css_selectors_target-within">No browser support yet as of 2020</a>).</li>
                <li><code>:scope</code> only useful with JavaScript since <code>&lt;style scoped&gt;</code> currently lacks browser support. I've not seen a compelling reason to use it yet.</li>
            </ul>
            <p>Note that privacy concerns may cause a browser to disregard developer-supplied <code>:link</code> / <code>:visited</code> styles. In that case it should still style them differently from each other.</p>
        </article>

        <article id="user-action-pseudo-classes">
            <h3>User action pseudo-classes</h3>
            <ul>
                <li><code>:hover</code> remember not all input modes are capable of hovering</li>
                <li><code>:active</code> for example, the state of a link between the time the mouse button is depressed to start to click on it, and the time that the button is released.</li>
            </ul>
            <h4>:focus and :focus-within</h4>
            <p><code>:focus</code> matches the currently focused element.</p>
            <p><code>:focus-within</code> matches an element when that element is an ancestor of the currently focused element. Note that <code>focus-within</code> is a rare example in CSS of being able to style an ancestor depending on the state of a descendant. [Well, okay, in theory there's <code>:has()</code>, but no browser supports that as of Jan 2021.]</p>
            <form method="GET" action="#" class="root-of-ui-pseudo-classes-search root-of-ui-pseudo-classes-search--form1 focus-within">
                <div><label for="form_focus"><code>:focus</code></label><input type="text" id="form_focus" name="form_focus"></div>
                <button type="submit">A submit button</button>
                <button type="reset">A reset button</button>
            </form>

            <h4>:focus-visible</h4>
            <p>This next form uses <code>focus-visible</code> rather than <code>focus</code>. This allows the user agent to use heuristics to determine whether to apply the rules or not, based on whether it seems that the user needs to know where the focus is. One example is navigation mode: both tabbing through and clicking on text inputs and buttons will result in any <code>focus</code> styles being used, whereas if you specify <code>focus-visible</code> instead, the browser decides whether or not to show them when the element receives focus. This is a good thing as clicking on a button and seeing a big outline appear unnecessarily on it can be ugly.
                <a href="https://caniuse.com/css-focus-visible">Check browser support</a>.</p>
            <form method="GET" action="#" class="root-of-ui-pseudo-classes-search root-of-ui-pseudo-classes-search--form2">
                <div><label for="form_focus-visible"><code>:focus-visible</code></label><input type="text" id="form_focus-visible" name="form_focus-visible"></div>
                <button type="submit">A submit button</button>
                <button type="reset">A reset button</button>
            </form>
        </article>

        <article class="root-of-input-pseudo-classes">
            <h3>Input pseudo-classes</h3>
            <h4>:disabled</h4>
            <p>Matches an interactive element that's explicitly disabled.</p>
            <button disabled="disabled">I'm disabled</button>
            <h4>:enabled</h4>
            <p>Matches an interactive element that's not explicitly disabled.</p>
            <button>I'm not disabled</button>
            <h4>:read-write</h4>
            <p>Matches an element that's user-alterable.</p>
            <input type="text" class="user-alterable">
            <h4>:read-only</h4>
            <p>Matches an element that's not user-alterable.</p>
            <p class="not-user-alterable">I'm not alterable by the user.</p>
            <h4 id="pc-placeholder-shown">:placeholder-shown</h4>
            <p>Matches an element that's currently displaying its placeholder. Note the difference compared to the pseudo-element
                <a href="#pe-placeholder"><code>::placeholder</code></a> , which matches the placeholder text itself.</p>
            <p>Showing a placeholder: <input type="text" placeholder="tell all!" class="may-have-placeholder"></p>
            <p>Not showing a placeholder: <input type="text" class="may-have-placeholder"></p>
            <h4>:default</h4>
            <p>Matches the default element in a set of radio buttons or checkboxes, the initially <code>selected</code> <code>&lt;option&gt;</code> element , and form's default submit button.</p>
            <label>radio 1<input type="radio" name="default-pseudo-class-demo"></label>
            <label>radio 2<input type="radio" name="default-pseudo-class-demo" checked></label>
            <label>radio 3<input type="radio" name="default-pseudo-class-demo"></label>
            <label>radio 4<input type="radio" name="default-pseudo-class-demo"></label>
            <h4>:checked</h4>
            <p>Matches checked checkboxes and radio buttons, and <code>selected</code> <code>&lt;option&gt;</code> elements.</p>
            <label>radio 1<input type="radio" name="checked-pseudo-class-demo"></label>
            <label>radio 2<input type="radio" name="checked-pseudo-class-demo" checked></label>
            <label>radio 3<input type="radio" name="checked-pseudo-class-demo"></label>
            <label>radio 4<input type="radio" name="checked-pseudo-class-demo"></label>
            <h4>:indeterminate</h4>
            <p><code>:indeterminate</code> matches a radio <code>&lt;input&gt;</code> element where no radio buttons are selected, and also a <code>&lt;progress&gt;</code> element that lacks a <code>value</code> attribute. A checkbox <code>&lt;input&gt;</code> element may match <code>:indeterminate</code> if its IDL <code>:indeterminate</code> property is set to true. Not sure in practice when that happens, but there's
                <a href="https://html.spec.whatwg.org/multipage/input.html#dom-input-indeterminate">some details in the WHATWG spec</a>.
            </p>
            <p>Here, matching <code>:indeterminate</code> elements have a teal border.</p>
            <div>
                <label>radio 1<input type="radio" name="indeterminate-pseudo-class-demo" class="indeterminate-pseudo-class-demo"></label>
                <label>radio 2<input type="radio" name="indeterminate-pseudo-class-demo" class="indeterminate-pseudo-class-demo"></label>
                <label>radio 3<input type="radio" name="indeterminate-pseudo-class-demo" class="indeterminate-pseudo-class-demo"></label>
                <label>radio 4<input type="radio" name="indeterminate-pseudo-class-demo" class="indeterminate-pseudo-class-demo"></label>
            </div>
            <div>
                <p>Click on the progress indicator below to toggle the presence of a <code>value</code> attribute:</p>
                <progress class="indeterminate-pseudo-class-demo" onclick="if(!this.getAttribute('value')){this.setAttribute('value', '0.5');}else{delete this.removeAttribute('value')}"></progress>
            </div>

            <h4>:required and :optional</h4>
            <p>Matches a form element whose value is required or optional, respectively.</p>
            <form action="" class="validation--required-optional">
                <label for="validity-demo-1-1" >A required field: </label><input type="text" id="validity-demo-1-1" required>
                <label for="validity-demo-1-2" >An optional field: </label><input type="text" id="validity-demo-1-2">
            </form>


            <h4>:valid and :invalid</h4>
            <p><code>:valid</code> matches <code>&lt;input&gt;</code> and <code>&lt;form&gt;</code> elements that validate successfully.
                <code>:invalid</code>matches elements that don't validate successfully. Elements without validity semantics can neither be
                <code>:valid</code> nor <code>:invalid</code>.</p>
            <form action="" class="validation">
                <label for="validity-demo-2" >Best food in the world (hint: there is only one answer, and it's
                    <b>"cheese"</b>)... Try it: </label><input type="text" id="validity-demo-2" pattern="cheese" value="something yucky">
            </form>

            <h4>:in-range and :out-of-range</h4>
            <p>Applies to form control elements with data range limits range limits.
            <form action="" class="validation">
                <label for="validity-demo-3" >This field is only valid for numerical inputs between 1 and 5, inclusive. Try it: </label><input type="number" id="validity-demo-3" min="1" max="5" value="2">
            </form>

            <h4>:user-invalid</h4>
            <p>A validation failure matching one of the above failure states, but only after the user has attempted to submit the form, and before they have interacted with it again. But also at other times too, at the discretion of the user-agent. No browser support yet as of Jan 2021.</p>

            <h4>:blank</h4>
            <p>Matches a user-input element that has no contents (not the same as <code>:empty</code>, which matches an element without any non-comment child nodes). Note that this is not supported in any browser and is marked as "at risk".</p>

        </article>
        <article>
            <h3>Time-based pseudo-classes :past, :current and :future (WebVTT)</h3>
            <p>Relate to currently displayed, or active position, in some timeline. Might be used for highlighting the currently spoken phrase from VTT, for example. No browser support information available.</p>
<!--            TODO: Demo-->
        </article>

        <article>
            <h3>Play-based pseudo-classes :playing and :paused</h3>
            <p>Note that <code>:playing</code> includes situations when the user intent is that the media is playing, even if it currently isn't, for example if the resource stream is buffering. <code>:paused</code> includes the state before playing has been activated by the user.</p>
            <!--            TODO: Demo-->
        </article>

        <article class="root-of-target-search">
            <h3>:target</h3>
            <p>matches the element with the id corresponding to the value of the fragment identifier portion of the document's URL.</p>
            <p><a href="#myTarget">get the target</a></p>
            <div id="myTarget">I am the target!</div>
        </article>

        <article>
            <h3>:lang</h3>
            <p>matches elements of the specified language. In contrast with the lang attribute selector, this <code>:lang</code> pseudo element takes many document methods of language specification into account (including the lang attribute).</p>
            <p>Make Portuguese text a different color:</p>
            <ul>
                <li lang="en-uk">Hello!</li>
                <li lang="pt">Ol&aacute;</li>
            </ul>
        </article>
    </section>

    <section>

        <h2>Pseudo-elements</h2>

        <p>Pseudo-elements are featureless, and so aren't matched by any other selector.</p>
        <p>As pseudo-elements don't modify the document tree, they do not affect the interpretation of structural pseudo-classes.</p>
        <p><a href="#user-action-pseudo-classes">User action pseudo-classes</a> are the only type of pseudo-classes that may be compounded to a pseudo-element, and then only if the definition of that user action pseudo-class permits it.</p>
        <p>Only pseudo-elements defined to have internal structure may be followed by descendant combinators.</p>
        <article>

            <h3>Typographic pseudo-elements</h3>

            <h4>::first letter</h4>
            <p><code>::first-letter</code> matches the first letter within an element.</p>
            <p class="first-letter-target">"First-letter" needn't be an actual letter, it refers to the first typographical letter unit on the first formatted line, so could be a digit, for example. It also includes any preceding punctuation and interleaving space. As <code>::first-letter</code> is always contained within <code>::first-line</code> if it exists, <code>::first-letter</code> can inherit from <code>::first-line</code>.</p>

            <h4>::first line</h4>
            <p><code>::first-line</code> matches the first letter within an element.</p>
            <p class="first-line-target">The first line of this paragraph is always going to be bold, no matter how long it is. If you resize the viewport, you will still be able to see the first line of this paragraph emboldened. That's how it works.</p>
            <p>Only a limited subset of CSS properties are usable to style <code>::first-line</code>.</p>

        </article>

        <article>

            <h3>Highlight pseudo-elements</h3>
            <p>Only a <a href="https://www.w3.org/TR/css-pseudo-4/#highlight-styling">very few properties may be set</a> on these. They mustn't affect layout, and must be performant.</p>

            <h4>::selection</h4>
            <p><code>:selection</code> refers to content selected to be the target or object of a future user interaction.</p>
            <ul>
                <li>Select me to see default browser selection styling.</li>
                <li><span class="root-of-selection-search">Select me to see styling via <code>::selection</code>.</span></li>
            </ul>

            <h4>::target-text</h4>
            <p><code>::target-text</code>represents text directly targeted by the document URL's fragment. Not totally clear what this means. See the
                <a href="https://www.w3.org/TR/css-pseudo-4/#selectordef-target-text">W3C reference</a>. There is no browser support as of Jan 2021, but Chrome has <a href="https://groups.google.com/a/chromium.org/g/blink-dev/c/yN2lrq67a1c/m/_Giqh2g_AwAJ?pli=1">expressed an intent to ship.</a> When it's out, the possibilities will become clear.</p>
            <p>One thing that is clear in the spec is that because of privacy concerns the page must not be able to read the styling of these pseudo-elements (similar to <code>:visited</code>.)</p>

            <h4>::spelling-error and ::grammar-error</h4>
            <p>What you'd expect. No browser support as of Jan 2021.</p>
        </article>

        <article>

            <h3>Tree-abiding pseudo-elements</h3>

            <h4>::before</h4>
            <p>Generates an element immediately before the originating element, containing the value specified in the <code>content</code> property (not generated if the value is <code>none</code>).</p>
            <div class="root-of-before-search">Generated indicators draw attention to this line.</div>

            <h4>::after</h4>
            <p>Generates an element immediately after the originating element, containing the value specified in the <code>content</code> property (not generated if the value is <code>none</code>).</p>

            <div class="root-of-after-search">Generated ellipsis indicates I'm cut off in mid sente</div>

            <h4>::marker</h4>
            <p><code>::marker</code> represents the marker box of a list item. Limited CSS properties available. <a href="https://caniuse.com/?search=%3A%3Amarker">Some browser support</a>, so consider an enhancement.</p>
            <ul class="root-of-marker-search">
                <li>thing 1</li>
                <li>thing 2</li>
            </ul>

            <h4 id="pe-placeholder">::placeholder</h4>
            <p><code>::placeholder</code> represents the <i>text</i> displayed as the placeholder. Compare this to the
                <a href="#pc-placeholder-shown"><code>:placeholder-shown</code></a> pseudo-class which selects <i>elements</i> that are displaying placeholder text. Limited to the same CSS properties as <code>::first-line</code>.</p>
            <input type="text" placeholder="holding the place" class="root-of-placeholder-search">
            
            <h4>::file-selector-button</h4>
            <p class="root-of-file-selector-button-search"><code>::file-selector-button</code> styles the file upload button of a <code>file</code> type input: <input type="file"></p>
            <p>This works in Firefox, but Webkit / Blink currently implement the non-standard <code>::-webkit-file-upload-button</code> (Jan 2021).</p>
        </article>

        <article>

            <h3>Caption-based pseudo-elements (WebVTT)</h3>

            <h4>::cue(selector)</h4>
            <p>Used without the optional selector, <code>::cue</code> styles a WebVTT track's cues as if they were a single unit, except background styling, which is applied individually Good browser support.</p>
            <p><code>::cue(selector)</code> <a href="https://caniuse.com/?search=%3A%3Acue">lacks Firefox support</a>, so be careful.</p>

            <h4>::cue-region</h4>
            <p>Not entirely sure what the practical difference is between this and <code>::cue </code>. No browser support info, so prolly not worth worrying about atm (Jan 2021).</p>
        </article>

        <article>

            <h3>Shadow DOM</h3>

            <h4>::part(part-name(s))</h4>
            <p>Shadow hosts may use the HTML attribute <code>part</code> to expose selected Shadow tree elements outside of the Shadow root. The <code>::part</code> pseudo-element allows them to be <b>styled by page-level CSS</b>. For example, if a Shadow element is exposed with <code>part="foo"</code>, then the page CSS may style it with <code>::part(foo)</code>.</p> Limited styling of <code>::part</code> with pseudo-classes is available, but only with those that use local element information, not those that are structural.
            <p>Good browser support.</p>
            <p>If you're really digging into this, this
                <a href="https://github.com/fergald/docs/blob/master/explainers/css-shadow-parts-1.md">more detailed explainer of <code>::part</code></a> may be useful. Note that it's from Jan 2019, so parts (ha!) may be out of date (I can't find any other references to <code>::theme</code>, for example, so this may have been dropped?).</p>
            <p>Also, remember that CSS custom properties pierce the Shadow boundary so could be used in conjunction with these.</p>

            <h4>::slotted(selector)</h4>
            <p><code>::slotted(selector)</code>, when <b>used by Shadow DOM CSS</b>, targets (only) element nodes placed into HTML template slots, which also match the specified selector.</p>
        </article>

<!--        TODO: add missing pseudo-elements from https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements -->
<!--        TODO: check web components for pseud-elements / pseudo-classes -->

    </section>
    <footer class="meta">Made by <a href="http://twitter.com/davidcmoulton">@davidcmoulton</a></footer>
</body>
</html>
