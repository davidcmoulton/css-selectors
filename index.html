<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Demonstration of CSS selectors</title>
    <meta name="description" content="Markup supporting selectors.css">
    <link rel="stylesheet" href="meta.css">
    <link rel="stylesheet" href="selectors.css">
</head>
<body>
    <header role="banner">
        <h1>Illustrative use of CSS selectors</h1>
    </header>

    <section>
        <h2>Basic</h2>
        <article>
            <h3>Universal selector</h3>
            <p>Match all non-pseudo-elements with <code>*</code>. Pseudo-elements need their own selectors, e.g. <code>*::after</code> will match all <code>after</code> pseudo-elements.</p>
        </article>

        <article>
            <h3>Element selector</h3>
            <p>Match the <code>&lt;dt&gt;</code> element with <code>dt</code>, so you can say this: <code>dt {  text-transform: uppercase; }</code>, and get this:</p>
            <dl>
                <dt>Some term</dt>
                <dd>An amazingly spot on definition of "some term".</dd>
            </dl>
        </article>

        <article>
            <h3>class selector</h3>
            <p>Make elements <span class="cls-bigger">bigger</span> with <code>.cls-bigger {  font-size: 1.5em; }</code> </p>
        </article>

        <article>
            <h3>multiple class selector</h3>
            <p><span class="cls-bigger cls-blue">Italicise</span> elements that are both
                <span class="cls-bigger">bigger</span> and <span class="cls-blue">blue</span> with <code>.cls-bigger.cls-blue { font-style: italic; }</code> </p>
        </article>

        <article>
            <h3>id selector</h3>
            <p>Make <span id="me">#me</span> bold with <code>#me { font-weight: bold; }</code></p>
        </article>
    </section>

    <section>
        <h2>Attributes</h2>
        <article>
            <h3>attribute selector: simple presence</h3>
            <p>Make uppercase an element assigned the attribute <code>data-hello-world</code> with <code>[data-hello-world] { text-transform: uppercase; }</code>. This will match no matter what the value of the attribute, or even if the attribute doesn't have a value.</p>
            <ul>
                <li>With <code>data-hello-world="true"</code>: <span data-hello-world="true">I'm uppercase</span>;</li>
                <li>with <code>data-hello-world="unicorns"</code>: <span data-hello-world="unicorns">I'm also uppercase</span>, and</li>
                <li>With the minimal <code>data-hello-world</code>: <span data-hello-world>I'm still uppercase</span>.</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: exact value match</h3>
            <p>Only highlight in yellow those elements with the attribute <code>data-highlight-color</code> set to the value "yellow".</p>
            <p>The attribute <code data-highlight-color="yellow">data-highlight-color="yellow"</code> matches <code>[data-highlight-color="yellow"]</code>, but <code data-highlight-color="none">data-highlight-color="none"</code> doesn't. Nor does the same value in a different case, e.g. <code data-highlight-color="YELLOW">data-highlight-color="YELLOW"</code></p>
        </article>

        <article>
            <h3>attribute selector: exact value match, case insensitive</h3>
            <p>Only highlight in blue those elements with the attribute <code>data-highlight-color</code> set to the value "blue" or e.g. "BLUE":</p>
            <ul>
                <li><code data-highlight-color="blue">data-highlight-color="blue"</code></li>
                <li><code data-highlight-color="BLUE">data-highlight-color="BLUE"</code></li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: exact value match, explicitly case sensitive</h3>
            <p>Only highlight in red those elements with the attribute <code>data-highlight-color</code> set to the value "RED" but not, e.g. "red":</p>
            <ul>
                <li><code data-highlight-color="red">data-highlight-color="red"</code></li>
                <li><code data-highlight-color="RED">data-highlight-color="RED"</code></li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: word match</h3>
            <p>Make the text green if "grass" is a word (a whitespace-separated string) in the value of the <code>data-floor-type</code> attribute, by matching <code>[data-floor-type~="grass"]</code> </p>
            <ul>
                <li><span data-floor-type="outside grass">This grass</span> has the attribute <code>data-floor-type="outside grass"</code></li>
                <li><span data-floor-type="outside patio">This patio</span> has the attribute <code>data-floor-type="outside patio"</code></li>
            </ul>
            <p>Check out this <span data-floor-type="outside grass">grass</span>, and this <span data-floor-type="outside patio">patio</span></p>
        </article>

        <article>
            <h3>attribute selector: starts with string</h3>
            <p>Match fully qualified links with <code>[href^="http"]</code></p>
            <ul class="external-link-search">
                <li>An <a href="http://external-link">external link</a> has an indicator</li>
                <li>A <a href="#">page fragment link to the current page</a> doesn't</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: ends with string</h3>
            <p>Match links ending in ".pdf" with <code>[href$=".pdf"]</code></p>
            <ul>
                <li><a href="#">Link to not-a-pdf</a></li>
                <li><a href="made-up-path.pdf">Link to a PDF</a></li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: value substring match</h3>
            <p>Match links containing the string "untrusted" in their path with <code>[href*="untrusted"]</code>.</p>

            <p>browse the <a href="./safe/">safe</a> directory with no worries, but be careful of the
                <a href="./untrusted">untrusted content.</a>
        </article>

        <article>
            <h3>attribute selector: beginning of a hyphen-separated value list</h3>
            <p>Used mainly for the use case: matching of elements with any <code>en</code> value of <code>hreflang</code>.</p>
            <ul>
                <li><a href="#" hreflang="en-UK">Good morning from the UK!</a></li>
                <li><a href="#" hreflang="en-AU">G'day from Oz!</a></li>
                <li><a href="#" hreflang="en-US">Howdy from the States!</a></li>
                <li><a href="#" hreflang="en">Hello from an unspecified English region</a></li>
                <li><a href="#" hreflang="fr">Bonjour de France!</a></li>
            </ul>

        </article>
    </section>

    <section>
        <h2>Structural</h2>
        <article>
            <h3>Descendant selector</h3>
            <p>Match any <code>&lt;span&gt;</code> living anywhere inside a <code>&lt;ul&gt;</code>, with <code>ul span</code>.</p>
            <div class="descendant-selector-search">
                <ul>
                    <li>I am not a span and so am not italic</li>
                    <li><span>I am an italic span as I'm inside a <code>ul</code>.</span></li>
                </ul>
                <span>I'm a span outside any <code>ul</code>, so am not italic.</span>
            </div>
        </article>

        <article>
            <h3>Child selector</h3>
            <p>Match any child <code>&lt;p&gt;</code> of <code>.parent</code>, but none nested more deeply, by using <code>.parent > p</code>.</p>
            <div class="child-selector-search">
                <p>I am an immediate child.</p>
                <p>I am another immediate child.
                </p>
                <div>
                    <p>I am a more remote descendant.</p>
                </div>
            </div>
        </article>

        <article>
            <h3>Adjacent sibling selector</h3>
            <p>Match a target element that immediately follows a specified sibling with <code>immediately-preceding-sibling-selector + target</code></p>
            <ul class="adjacent-sibling-search">
                <li>earlier sibling</li>
                <li class="specified-immediately-preceding-sibling">specified immediately preceding sibling</li>
                <li>the target</li>
                <li>later sibling</li>
            </ul>
        </article>

        <article>
            <h3>Following siblings selector</h3>
            <p>Match one or more targets that follow a specified sibling with <code>preceding-sibling-selector ~ target</code>.</p>
            <ul class="following-sibling-search">
                <li>earlier sibling</li>
                <li class="specified-preceding-sibling">specified preceding sibling</li>
                <li>a target</li>
                <li>another target</li>
            </ul>
        </article>
    </section>

    <section>
        <h3>Pseudo classes: structural</h3>
        <article>
            <h3>root</h3>
            <p>:root selects root element. Can also use html in html docs, but :root necessary for other doc types e.g. XML, SVG etc.</p>
        </article>

        <article>
            <h3>empty</h3>
            <p>:empty selects empty elements. N.B. elements, whitespace and text nodes prevent an element from being :empty. The presence of comment nodes does not prevent their parent element from being :empty.</p>
            <p>The middle list item is empty, and has content-after applied by its matched rule</p>
            <ul class="root-of-empty-search">
                <li>First element</li>
                <li></li>
                <li>Third element</li>
            </ul>
        </article>

        <article class="root-of-only-child-search">
            <h3>unique children</h3>
            <p>:only-child matches if the designated element is the only child of its parent (only evaluates element node type, ignores text). In the example below, the match to :only-child will be in small caps.</p>
            <p>In this paragraph, <span>this element</span> is the only child.</p>
            <p>In this paragraph, both <span>this</span>, and <span>this element</span>, are child elements of the same type.</p>
            <p>CSS Selector level 4 allows the selector to match an element without a parent. Check browser support if you need this feature.</p>
        </article>

        <article class="root-of-only-child-of-type-search">
            <h3>unique children of same type</h3>
            <p>:only-child-of-type matches if the designated element is the only child of that type of its parent (only evaluates element node type, ignores text). In the example below, the match to :only-child-of-type will be in small caps.</p>
            <p>In this paragraph, <span>this element</span> is the only child.</p>
            <p>In this paragraph, both <span>this</span>, and <span>this element</span>, are child elements of the same type.</p>
            <p>In this paragraph, <span>this</span>, and <label>this element</label>, are child elements of different types.</p>
            <p>CSS Selector level 4 allows the selector to match an element without a parent. Check browser support if you need this feature.</p>
        </article>

        <article>
            <h3>first child</h3>
            <p>matches the element where it appears as the first child of a parent.</p>
            <ul class="root-of-first-child-search">
                <li>first child</li>
                <li>second child</li>
                <li>third child</li>
            </ul>
        </article>

        <article>
            <h3>first child of type</h3>
            <p>matches the element where it appears as the first child of its element type of a parent. (May well not be the first element, though).</p>
            <p class="root-of-first-child-of-type-search">Here is a <label>label</label>, and here is a <span>span</span>. Oh, and another <span>span</span>.</p>
        </article>

        <article>
            <h3>last child</h3>
            <p>matches the element where it appears as the last child of a parent.</p>
            <ul class="root-of-last-child-search">
                <li>first child</li>
                <li>second child</li>
                <li>third child</li>
            </ul>
        </article>

        <article>
            <h3>last child of type</h3>
            <p>matches the element where it appears as the last child of its element type of a parent. (May well not be the last element, though).</p>
            <p class="root-of-last-child-of-type-search">Here is a <span>span</span>, and another <span>span</span>. And here is a <label>label</label>.</p>
        </article>

        <article>
            <h3>nth-child</h3>

            <h4>exactly this one, specific, nth child</h4>
            <p><code>:nth-child(2)</code> will target exactly the given element when it is the second child element of its parent.</p>
            <ul class="root-of-nth-child-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h4>every nth child</h4>
            <p><code>:nth-child(2n)</code> - an element of this type will be matched if it is 2 * nth child element of its parent (where n is the series 0 to the number of child elements).</p>
            <ul class="root-of-nth-child-xn-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h4>every nth child starting with offset</h4>
            <p><code>:nth-child(3n+2)</code> - an element of this type will be matched if it is 3 * n + 2th child element of its parent (where n is the series 0 to the number of child elements). Note that although in this example the offset is +2, the offset may be negative.</p>
            <ul class="root-of-nth-child-xn-offset-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h4>every even child</h4>
            <p>an element of this type will be matched if it is an even child of its parent</p>
            <ul class="root-of-nth-child-even-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h4>every odd child</h4>
            <p>an element of this type will be matched if it is an odd child of its parent</p>
            <ul class="root-of-nth-child-odd-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>
        </article>

        <article>
            <h3>nth-last-child</h3>

            <h4>exactly this one, specific, nth-last child</h4>
            <p><code>:nth-last-child(2)</code> will target exactly the given element when it is the second last child element of its parent.</p>
            <ul class="root-of-nth-last-child-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h4>every nth-last child</h4>
            <p><code>:nth-last-child(2n)</code> - an element of this type will be matched if it is 2 * nth-last child element of its parent (where n is the series 0 to the number of child elements).</p>
            <ul class="root-of-nth-child-xn-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h4>every nth-last child with offset</h4>
            <p><code>:nth-last-child(3n+2)</code> - an element of this type will be matched if it is 3 * n + 2th child element of its parent (where n is the series 0 to the number of child elements). Note that although in this example the offset is +2, the offset may be negative.</p>
            <ul class="root-of-nth-child-xn-last-offset-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

        </article>

        <article>
            <h3>nth-of-type</h3>
            <p>As nth-child, but only elements of the element type to match are included in the evaluation of the child count.</p>
        </article>

        <article>
            <h3>nth-last-of-type</h3>
            <p>As nth-of-type, but only elements of the element type to match are included in the evaluation of the child count.</p>
        </article>

        <article>
            <h3>is</h3>
            <p><code>is</code> (<code>matches</code> that was), takes a list of elements, any one of which will cause a match. Here, elements selected with <code>:is(span, q)</code> are coloured blue:</p>
            <div class="root-of-is-search">
                <span>I'm a <code>span</code></span> whereas <q>I'm a <code>q</code></q> and <i>I'm an <code>i</code></i>.
            </div>
            <p>Note that unlike the usual parsing rules of CSS, the selector list within <code>is</code> is forgiving: if a selector within <code>is</code> is not recognised by the browser, rather than invalidating the entire selector containing <code>is</code>, only the individual invalid selector within <code>is</code> is ignored.</p>
            <p>Check browser support.</p>
        </article>

        <article>
            <h3>where</h3>
            <p><code>where</code> always has a specificity of 0, but otherwise is identical to <code>is</code>. <code>is</code> takes the specificity of the most specific selector in its arguments.
        </article>


    </section>

    <section>
        <h2>Pseudo classes: dynamic</h2>
        <article>
            <h3>the anchor element's - :link, :visited, :hover, :active, :any-link</h3>
            <p>matches a elements in a particular dynamic state.</p>
            <div class="root-of-link-pseudo-classes-search">
                <div><a href="#" class="link-back-individual">link back: individual pseudo classes</a></div>
                <div><a href="#" class="link-back-any">link back: <code>any-link</code></a> matches all elements that match <code>:link</code> or <code>:visited</code>. (Check browser support.)</div>
            </div>
        </article>

        <article>
            <h3>UI state</h3>
            <p>typically used with forms.</p>
            <p>This example uses <code>enabled</code>, <code>disabled</code>, <code>checked</code>, <code>focus</code> and <code>focus-within</code>. Note that <code>focus-within</code> is a rare example in CSS of being able to style an ancestor depending on the state of a descendant. [Well, okay, in theory there's <code>has()</code>, but no browser supports that in November 2020.]</p>
            <form method="GET" action="#" class="root-of-ui-pseudo-classes-search root-of-ui-pseudo-classes-search--form1 focus-within">
                <div><label for="form1_isEnabled"><code>:enabled</code></label><input type="text" id="form1_isEnabled" name="form1_isEnabled"></div>
                <div><label for="form1_isDisabled"><code>:disabled</code></label><input type="text" id="form1_isDisabled" name="form1_isDisabled" disabled="disabled"></div>
                <div><label for="form1_focus"><code>:focus</code></label><input type="text" id="form1_focus" name="form1_focus"></div>
                <div><label for="form1_isChecked"><code>:checked</code></label><input type="checkbox" id="form1_isChecked" name="form1_isChecked" checked="checked"></div>
                <button type="submit">A submit button</button>
                <button type="reset">A reset button</button>
            </form>
            <p>This next form is identical to the one above, except that it uses <code>focus-visible</code> rather than <code>focus</code>. This allows the user agent to use heuristics to determine whether to show the <code>focus-visible</code> rules or not. One example is navigation mode: both tabbing through and clicking on text inputs and buttons will result in any <code>focus</code> styles being used. If you specify <code>focus-visible</code> styles instead, they will be still be displayed when tabbing through both input text fields and buttons, but won't be displayed on buttons when you click on them. This is a good thing as clicking on a button and seeing a big outline appear on it can be ugly. Check browser support.</p>
            <form method="GET" action="#" class="root-of-ui-pseudo-classes-search root-of-ui-pseudo-classes-search--form2 focus-within">
                <div><label for="form2_isEnabled"><code>:enabled</code></label><input type="text" id="form2_isEnabled" name="form2_isEnabled"></div>
                <div><label for="form2_isDisabled"><code>:disabled</code></label><input type="text" id="form2_isDisabled" name="form2_isDisabled" disabled="disabled"></div>
                <div><label for="form2_focus"><code>:focus</code></label><input type="text" id="form2_focus" name="form2_focus"></div>
                <div><label for="form2_isChecked"><code>:checked</code></label><input type="checkbox" id="form2_isChecked" name="form2_isChecked" checked="checked"></div>
                <button type="submit">A submit button</button>
                <button type="reset">A reset button</button>
            </form>
            <p>There is also the <code>:indeterminate</code>, pseudo class that can only be added programatically.</p>
        </article>

        <article>
            <h3>:target</h3>
            <p>matches the element with the id corresponding to the value of the fragment identifier portion of the document's URL.</p>
            <p><a href="#myTarget">get the target</a></p>
            <div id="myTarget">I am the target!</div>
        </article>

        <article>
            <h3>:lang</h3>
            <p>matches elements of the specified language. In contrast with the lang attribute selector, this <code>:lang</code> pseudo element takes many document methods of language specification into account (including the lang attribute).</p>
            <p>Make Portuguese text a different color:</p>
            <ul>
                <li lang="en-uk">Hello!</li>
                <li lang="pt">Ol&aacute;</li>
            </ul>
        </article>

        <article>
            <h3>:not() pseudo-class</h3>
            <p>matches elements that do not match the negated selector:</p>
            <ul class="root-of-negation-pseudo-classes-search">
                <li class="include-me">I'm included</li>
                <li class="include-me">I'm included</li>
                <li>I'm not included</li>
                <li class="include-me">I'm included</li>
            </ul>
        </article>

    </section>

    <section>
        <h2>Pseudo-elements</h2>
        <p>Pseudo element syntax uses '::' prefix (cf ':' prefix for pseudo classes).</p>

        <article>
            <h3>first letter</h3>
            <p><code>::first-letter</code> matches the first letter within an element</p>
            <p class="first-letter-target">First letter of this paragraph is bigger.</p>
        </article>

        <article>
            <h3>first line</h3>
            <p><code>::first-line</code> matches the first letter within an element</p>
            <p class="first-line-target">The first line of this paragraph is always going to be bold, no matter how long it is. If you resize the viewport, you will still be able to see the first line of this paragraph emboldened. That's how it works.</p>
        </article>

        <article>
            <h3><em>generated content</em></h3>
            <ul>
                <li>source content</li>
                <li class="put-stuff-before-me">source content</li>
                <li class="put-stuff-after-me">source content</li>
            </ul>
        </article>
    </section>
    <footer class="meta">Made by <a href="http://twitter.com/davidcmoulton">@davidcmoulton</a></footer>
</body>
</html>
