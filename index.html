<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Demonstration of CSS selectors</title>
    <meta name="description" content="Markup supporting selectors.css">
    <link rel="stylesheet" href="meta.css">
    <link rel="stylesheet" href="selectors.css">
</head>
<body>
    <header role="banner">
        <h1>Illustrative uses of CSS selectors</h1>
    </header>
<!--TODO: mention types of selectors, see level 4 spec-->
    <section>
        <h2>Basic</h2>
        <article>
            <h3>Universal selector</h3>
            <p>Match all non-pseudo-elements with <code>*</code>. So, to set all non-pseudo-elements in sans serif, use <code>* { font-family: sans-serif; }</code></p>
        </article>

        <article>
            <h3>Element selector</h3>
            <p>Match the <code>&lt;dt&gt;</code> element with the <code>dt</code> selector, so you can say this: <code>dt {  text-transform: uppercase; }</code>, and get this:</p>
            <dl>
                <dt>Some term</dt>
                <dd>An amazingly spot on definition of "some term".</dd>
            </dl>
        </article>

        <article>
            <h3>class selector</h3>
            <p>Match <span class="cls-bigger">elements with the class name <code>.cls-bigger</code></span></p>
        </article>

        <article>
            <h3>multiple class selector</h3>
            <p>Match <span class="cls-bigger cls-blue">an element</span> that is both
                <code>.cls-bigger</code> and <code>.cls-blue</code> with the multiple class selector <code>.cls-bigger.cls-blue</code>. In this case let's italicise it with <code>.cls-bigger.cls-blue {font-style: italic; }</code></p>
        </article>

        <article>
            <h3>id selector</h3>
            <p>Use the selector <code>#me</code> to match <span id="me">an element with an id of <code>me</code></span>.</p>
        </article>
    </section>

    <section>
        <h2>Attributes</h2>
        <article>
            <h3>attribute selector: simple presence</h3>
            <p>Match an element assigned the attribute <code>data-hello-world</code> with the selector <code>[data-hello-world]</code>. This will match no matter what the value of the attribute, or even if the attribute doesn't have a value.</p>
            <ul class="attribute-simple-presence-search">
                <li><code>data-hello-world="true"</code> <span data-hello-world="true">matches</span>;</li>
                <li><code>data-hello-world="false"</code> <span data-hello-world="true">matches</span>;</li>
                <li><code>data-hello-world="unicorns"</code> <span data-hello-world="unicorns">matches</span>, and</li>
                <li>the minimal <code>data-hello-world</code> also <span data-hello-world> matches</span>.</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: exact value match, case insensitive</h3>
            <p>Match those elements with the attribute <code>data-highlight-color</code> set to the value "blue" <strong>or</strong> e.g. "BLUE" (or any other case variation of the same string) using the selector <code>[data-highlight-color="blue" i]</code></p>
            <ul class="attribute-exact-match-case-insensitive-search">
                <li><code data-highlight-color="blue">data-highlight-color="blue"</code></li>
                <li><code data-highlight-color="BLUE">data-highlight-color="BLUE"</code></li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: exact value match, implicitly case sensitive</h3>
            <p>Only match those elements with the attribute <code>data-highlight-color</code> set to the value "RED" <strong>but not</strong>, e.g. "red" (nor any other case variation of the same string), using the selector <code>[data-highlight-color="RED"]</code>:</p>
            <ul class="attribute-exact-match-case-sensitive-search">
                <li><code data-highlight-color="red">data-highlight-color="red"</code></li>
                <li><code data-highlight-color="RED">data-highlight-color="RED"</code></li>
            </ul>
            <p>Note that case sensitivity can be explicitly specified with the selector <code>[data-highlight-color="RED" s]</code> under level 4, but not sure why you'd want to.</p>
        </article>

        <article>
            <h3>attribute selector: word match</h3>
            <p>Make the text green if "grass" is a word (a whitespace-separated string) in the value of the <code>data-ground-type</code> attribute, by matching <code>[data-ground-type~="grass"]</code> </p>
            <ul class="attribute-word-match-search">
                <li><span data-ground-type="grass outside">this field</span> has the attribute <code>data-ground-type="grass outside"</code> and matches</li>
                <li><span data-ground-type="outside grass">this meadow</span> has the attribute <code>data-ground-type="outside grass"</code> and matches</li>
                <li><span data-ground-type="outside grass garden">this lawn</span> has the attribute <code>data-ground-type="outside grass garden"</code> and matches</li>
                <li><span data-ground-type="outside patio">this patio</span> has the attribute <code>data-ground-type="outside patio"</code> and doesn't match</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: starts with string</h3>
            <p>Match fully qualified links with <code>[href^="http"]</code></p>
            <ul class="attribute-starts-with-search">
                <li>An <a href="http://external-link">external link</a> has an indicator</li>
                <li>A <a href="#">page fragment link to the current page</a> doesn't</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: ends with string</h3>
            <p>Match links ending in ".pdf" with <code>[href$=".pdf"]</code></p>
            <ul class="attribute-ends-with-match-search">
                <li>A <a href="made-up-path.pdf">link to a PDF</a> has an indicator</li>
                <li>A <a href="#">link to not-a-pdf</a> doesn't</li>
            </ul>
        </article>

        <article>
            <h3>attribute selector: substring match</h3>
            <p>Match links containing the string "untrusted" in their path with <code>[href*="untrusted"]</code>.</p>

            <p class="attribute-substring-match">Browse the <a href="./safe/">safe</a> content with confidence, but be careful of the
                <a href="./untrusted">untrusted</a> content.
        </article>

        <article>
            <h3>attribute selector: beginning of a hyphen-separated value list</h3>
            <p>Used mainly for the use case: matching of elements with any <code>en</code> value of <code>hreflang</code>.</p>
            <ul class="attribute-hyphen-separated-list-start-search">
                <li><a href="#" hreflang="en-UK">Good morning from the UK!</a></li>
                <li><a href="#" hreflang="en-AU">G'day from Oz!</a></li>
                <li><a href="#" hreflang="en-US">Howdy from the States!</a></li>
                <li><a href="#" hreflang="en">Hello from an unspecified English region</a></li>
                <li><a href="#" hreflang="fr">Bonjour de France!</a></li>
            </ul>

        </article>
    </section>

    <section>
        <h2>Structural complex selectors</h2>
        <article>
            <h3>Descendant selector</h3>
            <p>Match any <code>&lt;span&gt;</code> living anywhere inside a <code>&lt;ul&gt;</code>, with <code>ul span</code>.</p>
            <div class="descendant-selector-search">
                <ul>
                    <li>I am not a span and so am not italic</li>
                    <li><span>I am an italic span as I'm inside a <code>ul</code>.</span></li>
                </ul>
                <span>I'm a span outside any <code>ul</code>, so am not italic.</span>
            </div>
        </article>

        <article>
            <h3>Child selector</h3>
            <p>Match any child <code>&lt;p&gt;</code> of <code>.parent</code>, but none nested more deeply, by using <code>.parent > p</code>, in this case turning it steel blue.</p>
            <div class="child-selector-search">
                <p>The <code>&lt;p&gt;</code> in <code>&lt;div class="parent"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;</code> is a child of <code>.parent</code>, so this matches.</p>
                <div>
                    <p>The <code>&lt;p&gt;</code> in <code>&lt;div class="parent"&gt;&lt;div&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</code> is not a child of <code>.parent</code>, so this doesn't match.</p>
                </div>
            </div>
        </article>

        <article>
            <h3>Adjacent sibling selector</h3>
            <p>Match a target element that immediately follows a specified sibling with <code>immediately-preceding-sibling-selector + target-selector</code></p>
            <ul class="adjacent-sibling-search">
                <li>earlier sibling</li>
                <li class="specified-immediately-preceding-sibling">specified immediately preceding sibling</li>
                <li>the target</li>
                <li>later sibling</li>
            </ul>
        </article>

        <article>
            <h3>Following siblings selector</h3>
            <p>Match one or more targets that follow a specified sibling with <code>preceding-sibling-selector ~ target</code>.</p>
            <ul class="following-sibling-search">
                <li>earlier sibling</li>
                <li class="specified-preceding-sibling">specified preceding sibling</li>
                <li>a target</li>
                <li>another target</li>
            </ul>
        </article>

        <article>
            <h3>Table / grid column selector</h3>
            <p>Match a target within the specified column of a table or grid. No implementations yet in 2020, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Column_combinator">more details on MDN</a>.</p>
        </article>

    </section>

    <section>
        <h2>Logical pseudo-classes</h2>
        <article>
            <h3>:is</h3>
            <p><code>:is</code> (used to be called <code>:matches</code>), takes a list of elements, any one of which will cause a match. Here, elements selected with <code>:is(span, q)</code> are coloured blue:</p>
            <div class="root-of-is-search">
                <span>I'm a <code>matching span</code></span> and <q>I'm a <code>matching q</code></q>, but <i>I'm a non-matching <code>i</code></i>.
            </div>
            <p>Note that unlike the usual parsing rules of CSS, the selector list within <code>is</code> is forgiving: if a selector within <code>is</code> is not recognised by the browser, rather than invalidating the entire selector containing <code>is</code>, only the individual invalid selector within <code>is</code> is ignored.</p>
            <p><code>is</code> takes the specificity of the most specific selector in its arguments.</p>
            <p><a href="https://caniuse.com/css-matches-pseudo">Check browser support</a>.</p>
        </article>

        <article>
            <h3>:where</h3>
            <p><code>:where</code> always has a specificity of 0, but otherwise is identical to <code>:is</code>.
        </article>

        <article>
            <h3>:has</h3>
            <p><code>:has</code> takes a selector list as an argument and matches the selector it's bound to when any selector in the list matches. This could easily be used to match an element based on its descendants. Before level 4 this was not possible in CSS. Unfortunately as of 2020 there is no browser support yet, but you can
                <a href="https://caniuse.com/?search=%3Ahas">keep an eye on it</a>.</p>
        </article>

        <article>
            <h3>:not</h3>
            <p>
                <code>:not</code> matches elements that do not match the supplied selector or selector list. Note that you can't pass pseudo-elements, they won't work with <code>:not</code>. Browser support is good for passing a single selector; if you want to pass a selector list (this is the level 4 addition),
                <a href="https://caniuse.com/css-not-sel-list">check browser support</a>.
            </p>

            <h4>Passing a single selector</h4>
            <p>To match all but the third child in the list, use <code>li:not( :nth-child(3) )</code></p>
            <ul class="not-single-selector-search">
                <li>I am child number 1</li>
                <li>I am child number 2</li>
                <li>I am child number 3</li>
                <li>I am child number 4</li>
            </ul>
            <p>You can chain individual single selector <code>:not</code>s together to get some of the effect of a selector list, for example to match all but the first and last list items, you can use <code>li:not(:first-child):not(:last-child)</code></p>
            <ul class="not-multiple-single-selectors-search">
                <li>I am child number 1</li>
                <li>I am child number 2</li>
                <li>I am child number 3</li>
                <li>I am child number 4</li>
            </ul>


            <h4>Passing a selector list</h4>
            <p>To match all but the first and last list items, as above but using a selector list instead of multiple <code>:not</code> clauses, use <code>li:not( :first-child, :last-child)</code></p>
            <ul class="not-selector-list-search">
                <li>I am child number 1</li>
                <li>I am child number 2</li>
                <li>I am child number 3</li>
                <li>I am child number 4</li>
            </ul>
        </article>
    </section>

    <section>
        <h2>Structural pseudo-classes</h2>
        <article>
            <h3>:root</h3>
            <p><code>:root</code> matches the root element. Can also use <code>&lt;html&gt;</code> in html docs, but <code>:root</code> is necessary for other doc types e.g. XML, SVG etc.</p>
        </article>

        <article>
            <h3>:empty</h3>
            <p><code>:empty</code> matches empty elements. N.B. element nodes and text nodes (including whitespace) prevent a containing element from being empty. Comment nodes do not prevent their parent element from being empty.</p>
            <p>Here, empty list items have a background pattern applied.</p>
            <ul class="root-of-empty-search">
                <li>First element</li>
                <li></li>
                <li>Third element</li>
            </ul>
        </article>

        <h3>Child-indexed pseudo-classes</h3>
        <p>Selectors level 3 describes this type of matching as being based on the index of the target  element relative to its parent, as encapsulated in the inclusion of "child" in some of the pseudo-class names. Selectors level 4 allows for a non-element parent, or no parent at all, by describing an element's relative index with respect to its siblings. Language in this section refers to "child" to match the pseudo class names, but if you're in a level 4 implementation, the implied parent is not a requirement.</p>

        <p>Note that <em>indices are always 1-indexed</em>.</p>

        <article>
            <h3>:only-child</h3>
            <p><code>:only-child</code> matches if an element is the only child element of its parent.</p>
            <p class="only-child-search">In this paragraph, <span>I am the only child element, so I match, (it doesn't matter what type of element I am).</span></p>
            <p class="only-child-search">In this paragraph, there is more than one child, both <i>here</i> and <i>here</i>, so the <code>:only-child</code> selector doesn't find a match.</p>
        </article>

        <article>
            <h3>:only-of-type</h3>
            <p><code>:only-of-type</code> matches an element of specified type that is the only child element of that type of its parent. Here we're using <code>span:only-of-type</code> to target <code>&lt;span&gt;</code> elements that are the only span element of their parents:</p>
            <p class="only-of-type-search">In this paragraph, <span>this <code>&lt;span&gt;</code></span>, and <label>this <code>&lt;label&gt;</code>element</label>, are the only child elements of their respective types, so the <code>span:only-child-of-type</code> selector matches the span but not the label.</p>
            <p class="only-of-type-search">In this paragraph, both <span>this <code>&lt;span&gt;</code></span>, and <span>this <code>&lt;span&gt;</code></span>, are child elements of the same parent, so the selector doesn't match.</p>
        </article>

        <article>
            <h3>:first-child</h3>
            <p><code>:first-child</code> matches an element that is the first child of its parent.</p>
            <ul class="first-child-search">
                <li>first child</li>
                <li>second child</li>
                <li>third child</li>
            </ul>
        </article>

        <article>
            <h3>:first-of-type</h3>
            <p><code>:first-of-type</code> matches an element that is the first child element of its type, (it needn't be the first overall element child). Here we're using <code>span:first-of-type</code> to select the first <code>&lt;span&gt;</code> element.</p>
            <p class="root-of-first-of-type-search">This paragraph contains a <label><code>&lt;label&gt;</code></label>, this first <span><code>&lt;span&gt;</code> which matches</span>, and this second <span><code>&lt;span&gt;</code></span>, which doesn't.</p>
        </article>

        <article>
            <h3>:last-child</h3>
            <p><code>:last-child</code> is the converse of <code>:first-child</code>.</p>
            <ul class="root-of-last-child-search">
                <li>first child</li>
                <li>second child</li>
                <li>last child</li>
            </ul>
        </article>

        <article>
            <h3>:last-of-type</h3>
            <p><code>:last-of-type</code> is the converse of <code>:first-of-type</code>.</p>
            <p class="root-of-last-of-type-search">This paragraph contains a <label><code>&lt;label&gt;</code></label>, this first <span><code>&lt;span&gt;</code> which doesn't match</span>, and this second <span><code>&lt;span&gt;</code>, which does</span>.</p>
        </article>

        <article>
            <h4>The An+B microsyntax</h4>
            <p>Some of these function-like pseudo-elements are invoked with <code>(An+B)</code>, which can be useful to match a specific child, or all child elements at regularly spaced intervals. Child-indexed pseudo-class selectors using this microsyntax match a child element when its index is the result of the evaluation of terms inside the parentheses. You can think of the child list as being is divided into <code>A</code> groups (the last group also containing any remainder), and it's the <code>B</code>th element of each group that is matched.</p>
            <p>For <code>An+B</code>, <code>n</code> is a literal representing consecutive integers between 0 and the number of child elements, <code>A</code>represents a multiple of <code>n</code>, and <code>B</code> is an integer offset which may be positive, negative, or 0.</p>
            <ul>
                <li>If <code>A</code> is 0 it may be omitted, so the expression becomes <code>(B)</code>, which will match exactly one element with that index (if a child element of the specified index exists).</li>
                <li>If <code>A</code> is 1 or -1, it may be omitted, as long as the correct sign is applied to <code>n</code>, so that <code>1n</code> becomes <code>n</code> and <code>-1n</code> becomes <code>-n</code>.</li>
                <li>If B is 0 it may be omitted, so the expression becomes <code>(An)</code>, which will match every Ath child element.</li>
                <li>If B is negative, the expression becomes <code>(An-B)</code></li>
            </ul>
            <p>Just a few of the things you can do with this are shown as examples below:</p>


            <h4>:nth-child(An+B of S)</h4>
            <p>Counts from the beginning of the list of child elements.</p>
            <p><code>S</code> represents a user-supplied selector list used to scope the child list, think of it as a more flexible version of <code>:nth-of-type</code> where you're not restricted to scoping by the type of the child element. [Note that as at December 2020, only Safari supports <code>of S</code>, so the scoping isn't ready for prime time yet, but keep an eye on the
                <a href="https://caniuse.com/css-nth-child-of">browser support</a>.</p>
            <h5>exactly this one, specific child</h5>
            <p><code>:nth-child(2)</code> will match exactly the second child.</p>
            <ul class="root-of-nth-child-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h5>the first 4 children</h5>
            <p><code>:nth-child(-n+4)</code> will match the first four children.</p>
            <ul class="root-of-nth-child-first-four-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h5>every second child</h5>
            <p><code>:nth-child(2n)</code> will match every other child, starting with the second. (Note that <code>2n</code> is aliased to <code>even</code>, so the more readable <code>:nth-child(even)</code> may be preferred.)</p>
            <ul class="root-of-nth-child-xn-even-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <p><code>:nth-child(2n+1)</code> will match every other child, starting with the first. (Note that <code>2n+1</code> is aliased to <code>odd</code>, so the more readable <code>:nth-child(odd)</code> may be preferred.)</p>
            <ul class="root-of-nth-child-xn-odd-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
            </ul>

            <h5>every third child, starting counting from the second</h5>
            <p><code>:nth-child(3n+2)</code> will match the second child, then every third one after that.</p>
            <ul class="root-of-nth-child-xn-offset-search">
                <li>first child</li>
                <li>Second child</li>
                <li>Third child</li>
                <li>Fourth child</li>
                <li>Fifth child</li>
                <li>Sixth child</li>
                <li>Seventh child</li>
                <li>Eighth child</li>
                <li>Ninth child</li>
                <li>Tenth child</li>
                <li>Eleventh child</li>
                <li>Twelfth child</li>
                <li>Thirteenth child</li>
                <li>Fourteenth child</li>
            </ul>
        </article>

        <article>
            <h4>:nth-last-child(An+B)</h4>
            <p>The same as <code>:nth-child</code>, but counting from the end rather than the beginning of the list of child elements.</p>
        </article>

        <article>
            <h4>:nth-of-type(An+B)</h4>
            <p>As <code>:nth-child</code>, but only elements of the element type to match are included in the evaluation of the child count. It is more specific than <code>:nth-child</code>.</p>
        </article>

        <article>
            <h4>:nth-last-of-type(An+B)</h4>
            <p>As <code>:nth-last-child</code>, but only elements of the element type to match are included in the evaluation of the child count. It is more specific than <code>:nth-last-child</code>.</p>
        </article>

    </section>

    <section>
        <h2>Dynamic pseudo-classes</h2>
        <article>
            <h3>Location pseudo-classes</h3>
            <ul>
                <li><code>:link</code> matches any unvisited <code>&lt;a&gt;</code>.</li>
                <li><code>:visited</code> matches any visited <code>&lt;a&gt;</code>.</li>
                <li><code>:local-link</code> matches any reflexive link within the current document. If the <code>href</code> includes a fragment identifier, this must be matched in the document's URL for the selector to match. No browser support data available as of 2020.</li>
                <li><code>:any-link</code> matches any <code>&lt;a&gt;</code>, <code>&lt;area&gt;</code> or <code>&lt;link&gt;</code> with an <code>href</code> attribute.</li>
                <li><code>:target</code> matches the element referenced by the document URL's fragment identifier, if any.</li>
                <li><code>:target-within</code> matches when an element, or a descendant element, is referenced by the document URL's fragment identifier, if any. (This is a rare example in CSS of being able to style an ancestor based on a descendant. <a href="https://caniuse.com/mdn-css_selectors_target-within">No browser support yet as of 2020</a>).</li>
                <li><code>:scope</code> only useful with JavaScript since <code>&lt;style scoped&gt;</code> currently lacks browser support. I've not seen a compelling reason to use it yet.</li>
            </ul>
            <p>Note that privacy concerns may cause a browser to disregard developer-supplied <code>:link</code> / <code>:visited</code> styles. In that case it should still style them differently from each other.</p>
        </article>

        <article>
            <h3>User action pseudo-classes</h3>
            <ul>
                <li><code>:hover</code> remember not all input modes are capable of hovering</li>
                <li><code>:active</code> for example, the state of a link between the time the mouse button is depressed to start to click on it, and the time that the button is released.</li>
            </ul>
            <h4>:focus and :focus-within</h4>
            <p><code>:focus</code> matches the currently focused element.</p>
            <p><code>:focus-within</code> matches an element when that element is an ancestor of the currently focused element. Note that <code>focus-within</code> is a rare example in CSS of being able to style an ancestor depending on the state of a descendant. [Well, okay, in theory there's <code>has()</code>, but no browser supports that as of 2020.]</p>
            <form method="GET" action="#" class="root-of-ui-pseudo-classes-search root-of-ui-pseudo-classes-search--form1 focus-within">
                <div><label for="form_focus"><code>:focus</code></label><input type="text" id="form_focus" name="form_focus"></div>
                <button type="submit">A submit button</button>
                <button type="reset">A reset button</button>
            </form>

            <h4>:focus-visible</h4>
            <p>This next form is identical to the one above, except that it uses <code>focus-visible</code> rather than <code>focus</code>. This allows the user agent to use heuristics to determine whether to apply the rules or not, based on whether it seems that the user needs to know where the focus is. One example is navigation mode: both tabbing through and clicking on text inputs and buttons will result in any <code>focus</code> styles being used, whereas if you specify <code>focus-visible</code> instead, the browser decides whether or not to show them when the element receives focus. This is a good thing as clicking on a button and seeing a big outline appear unnecessarily on it can be ugly.
                <a href="https://caniuse.com/css-focus-visible">Check browser support</a>.</p>
            <form method="GET" action="#" class="root-of-ui-pseudo-classes-search root-of-ui-pseudo-classes-search--form2 focus-within">
                <div><label for="form_focus-visible"><code>:focus-visible</code></label><input type="text" id="form_focus-visible" name="form_focus-visible"></div>
                <button type="submit">A submit button</button>
                <button type="reset">A reset button</button>
            </form>
        </article>

        <article>
            <h3>Input pseudo-classes</h3>
            <h4>:disabled</h4>
            <p>Matches an interactive element that's explicitly disabled.</p>
            <h4>:enabled</h4>
            <p>Matches an interactive element that's not explicitly disabled.</p>
            <h4>:read-write</h4>
            <p>Matches an element that's user-alterable.</p>
            <h4>:read-only</h4>
            <p>Matches an element that's not user-alterable.</p>
            <h4>:placeholder-shown</h4>
            <p>Matches an element that's currently displaying its placeholder.</p>
            <h4>:default</h4>
            <p>Matches the default element in a set of radio buttons or checkboxes, the initally <code>selected</code> <code>&lt;option&gt;</code> element , and form's default submit button.</p>
            <h4>:checked</h4>
            <p>Matches checked checkboxes and radio buttons, and <code>selected</code> <code>&lt;option&gt;</code> elements.</p>
            <h4>:indeterminate</h4>
            <p><code>:indeterminate</code> matches a radio <code>&lt;input&gt;</code> element where no radio buttons are selected, and also a <code>&lt;progress&gt;</code> element that lacks a <code>value</code> attribute. A checkbox <code>&lt;input&gt;</code> element may match <code>:indeterminate</code> if its IDL <code>:indeterminate</code> property is set to true. Not sure in practice when that happens, but there's
                <a href="https://html.spec.whatwg.org/multipage/input.html#dom-input-indeterminate">some details in the WHATWG spec</a>.
            </p>
            <h4>:blank</h4>
            <p>Matches a user-input element that has no contents (not the same as <code>:empty</code>, which matches an element without any non-comment child nodes). Note that this is not supported in any browser and is marked as "at risk".</p>
        </article>
        <article>
            <h3>Time-based pseudo-classes :past, :current and :future</h3>
            <p>Relate to currently displayed, or active position, in some timeline. Might be used for highlighting the currently spoken phrase from VTT, for example. No browser support information available.</p>
        </article>

        <article>
            <h3>Play-based pseudo-classes :playing and :paused</h3>
            <p>Note that <code>:playing</code> includes situations when the user intent is that the media is playing, even if it currently isn't, for example if the resource stream is buffering. <code>:paused</code> includes the state before playing has been activated by the user.</p>
        </article>

        <article>
            <h3>:target</h3>
            <p>matches the element with the id corresponding to the value of the fragment identifier portion of the document's URL.</p>
            <p><a href="#myTarget">get the target</a></p>
            <div id="myTarget">I am the target!</div>
        </article>

        <article>
            <h3>:lang</h3>
            <p>matches elements of the specified language. In contrast with the lang attribute selector, this <code>:lang</code> pseudo element takes many document methods of language specification into account (including the lang attribute).</p>
            <p>Make Portuguese text a different color:</p>
            <ul>
                <li lang="en-uk">Hello!</li>
                <li lang="pt">Ol&aacute;</li>
            </ul>
        </article>
    </section>

    <section>
        <h2>Pseudo-elements</h2>
<!--        TODO:
                ::before
                ::after
                -->
        <p>Pseudo element syntax uses '::' prefix (cf ':' prefix for pseudo classes).</p>

        <article>
            <h3>first letter</h3>
            <p><code>::first-letter</code> matches the first letter within an element</p>
            <p class="first-letter-target">First letter of this paragraph is bigger.</p>
        </article>

        <article>
            <h3>first line</h3>
            <p><code>::first-line</code> matches the first letter within an element</p>
            <p class="first-line-target">The first line of this paragraph is always going to be bold, no matter how long it is. If you resize the viewport, you will still be able to see the first line of this paragraph emboldened. That's how it works.</p>
        </article>

        <article>
            <h3><em>generated content</em></h3>
            <ul>
                <li>source content</li>
                <li class="put-stuff-before-me">source content</li>
                <li class="put-stuff-after-me">source content</li>
            </ul>
        </article>
    </section>
    <footer class="meta">Made by <a href="http://twitter.com/davidcmoulton">@davidcmoulton</a></footer>
</body>
</html>
